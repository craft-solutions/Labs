/**
 * This file was generated by Craft Solutions team, and the code
 * bellow should not be copied, transfered, or tamper with in part
 * or in total without the express authorization of the directing
 * parties of Craft or the authoring clients defined by Craft.
 *
 * Fail to complain to these requirements make the party subject
 * for legal actions and prosecution. For more details contact
 * Craft Solutions at contact@craft-solutions.com.
 */
package com.craft.anje.avatarsocial;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.Properties;
import java.util.Random;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.io.FileUtils;

/**
 * <p> Base servlet for all the servlet runtimes in the system. </p>
 *
 * Created on 20/11/2014
 * @version CRAFT-PBCA-1.0
 * @author <a href="mailto:joao.rios@craft-solutions.com">Joao Gonzalez</a>
 */
public abstract class BaseServlet extends HttpServlet {
	private static final long serialVersionUID = 8709314003412260885L;
	
	private static long lastTimestampMillis = System.currentTimeMillis();
	private static Properties configurationProperties = new Properties();
	
	private final String X_CRAFT_NMI = "X-Craft-NMI";
	private final String X_CRAFT_RC = "X-Craft-RC";
	private final String X_CRAFT_RCMSG = "X-Craft-RCMessage";
	private final String X_CRAFT_ACTION = "X-Craft-Action";
	private final String X_CRAFT_ACTION_RESULT = "X-Craft-ActionResult";

	/**
	 * <p> Returns the access token to he used to validate the request. </p>
	 * @param session	The session to be used
	 * @return	The NMI token
	 * @throws AvatarException
	 */
	protected int getAccessTokenNMI (HttpSession session) throws AvatarException {
		Integer number = (Integer) session.getAttribute(IConstants.SESSION_TOKEN);
		
		// verify if the token exists
		if (number == null) {
			throw new AvatarException("No NMI found!", IRC.ERR_NEWTOKEN);
		}
		else return number;
	}
	
	/**
	 * <p> Returns the solutions base directory. </p>
	 * @return	Base directory
	 * @throws IOException
	 */
	protected File getBaseDirectory () throws IOException {
		// Creates the solution Directory
		File soldir = new File(FileUtils.getUserDirectory(), "craft");
		if (!soldir.exists() || soldir.isFile()) {
			soldir.mkdir();
		}
		
		return soldir;
	}
	/**
	 * <p> Returns the batch video directory. </p>
	 * @return	The batch directory
	 * @throws IOException
	 */
	protected File getFileBatchDirectory () throws IOException {
		File baseDir = getBaseDirectory();
		File batchFileDir = new File (baseDir, "batch");
		if ( !batchFileDir.exists() || batchFileDir.isFile() ) {
			batchFileDir.mkdir();
		}
		
		return batchFileDir;
	}
	/**
	 * <p> Gets the file extension. </p>
	 * @return	The file ext
	 * @throws IOException
	 */
	protected String getFileExtension () throws IOException {
		return getConfiguration().getProperty(IConstants.PROPERTY_FILE_EXT);
	}
	/**
	 * <p> Returns the number of video parts in the directory. </p>
	 * @return
	 * @throws IOException
	 */
	protected int countVideoParts () throws IOException {
		Collection<File> files = FileUtils.listFiles(getFileBatchDirectory(), new String []{getFileExtension()}, false);
		if (files!=null) {
			return files.size();
		}
		else return 0;
	}
	
	/**
	 * <p> Gets the configuration properties to be used by the servlet session. </p>
	 * @return	The configuration properties
	 * @throws IOException
	 */
	protected Properties getConfiguration () throws IOException {
		File soldir = getBaseDirectory();
		File configFile = new File (soldir, "configurations.properties");
		if (!configFile.exists() || configFile.isDirectory()) {
			configFile.createNewFile();
			
			InputStream in = getClass ().getResourceAsStream("/configurations.properties");
			FileUtils.copyInputStreamToFile(in, configFile);
			
			// Loads the configurations
			configurationProperties.load(in);
			
			lastTimestampMillis = System.currentTimeMillis();
		}
		else {//if ( (System.currentTimeMillis()-lastTimestampMillis) > (1000*60*60/*1 hour*/)) {
			FileInputStream fin = new FileInputStream(configFile);
			
			// Loads the configurations
			configurationProperties.load(fin);
			
			lastTimestampMillis = System.currentTimeMillis();
		}
		
		return configurationProperties;
	}
	
	/**
	 * <p> Execute the process of video streaming queuing. </p>
	 * @param request	The HTTP request sent from the client
	 * @param response	The HTTP response to be delivered to the client
	 * @throws AvatarException	If something horrible occurs
	 * @throws IOException
	 */
	abstract protected void execute (HttpServletRequest request, HttpServletResponse response) throws AvatarException, IOException;
	/**
	 * Identifies if the implementing servlet should use a get method
	 * @return	True if it can use GET, false otherwise
	 */
	abstract protected boolean canUseGET ();
	
	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws AvatarException, IOException {
		HttpSession session = request.getSession();
		try {
			// Gets the token
			int token = getAccessTokenNMI(session);
			
			int givenToken = request.getIntHeader(X_CRAFT_NMI);
			
//			System.out.format("Given Token [%d] === SESSION TOKEN [%d]\n", givenToken, token);
			if ( givenToken == -17 ) {
				throw new AvatarException("Needs new token", IRC.ERR_NEWTOKEN);
			}
			else if ( (token % givenToken) != 0 ) {
				response.setIntHeader(X_CRAFT_RC, IRC.ERR_SECURITY);
				throw new AvatarException("Internal Server validation error", IRC.ERR_SECURITY);
			}
			// Okay, continue processing
			else {
				this.execute(request, response);
				
				// Okay, no error has happen
				response.setIntHeader(X_CRAFT_RC, IRC.ERR_NONE);
				
			}
		}
		catch (Throwable t) {
			if ( t instanceof AvatarException ) {
				AvatarException aex = (AvatarException) t;
				response.setIntHeader(X_CRAFT_RC, aex.getRC());
				response.setHeader(X_CRAFT_RCMSG, t.getMessage()!=null?t.getMessage():"No information");
			}
			else {
				response.setIntHeader(X_CRAFT_RC, IRC.ERR_UNKNOWN);
				response.setHeader(X_CRAFT_RCMSG, t.getMessage()!=null?t.getMessage():"No information");
			}
		}
	}
	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws AvatarException, IOException {
		// Verifies if it's a token generation process
		if (verifyAuthorityNumber(request)) {
			Integer number = new Random(System.currentTimeMillis()).nextInt(Character.MAX_VALUE*100);
			
			// Saves the token
			request.getSession().setAttribute(IConstants.SESSION_TOKEN, number);
			
			// Define the header with the token value
			response.setIntHeader(X_CRAFT_ACTION_RESULT, number);
			response.setIntHeader(X_CRAFT_RC, IRC.ERR_NONE);
		}
		else if (canUseGET()) {
			try {
				this.execute (request, response);
			}
			catch (Throwable t) {
				if ( t instanceof AvatarException ) {
					AvatarException aex = (AvatarException) t;
					response.setIntHeader(X_CRAFT_RC, aex.getRC());
					response.setHeader(X_CRAFT_RCMSG, t.getMessage()!=null?t.getMessage():"No information");
				}
				else {
					response.setIntHeader(X_CRAFT_RC, IRC.ERR_UNKNOWN);
					response.setHeader(X_CRAFT_RCMSG, t.getMessage()!=null?t.getMessage():"No information");
				}
			}
		}
		else {
			// Just write a forbidden message to the client
			response.sendError(HttpServletResponse.SC_FORBIDDEN);
		}
	}
	private boolean verifyAuthorityNumber (HttpServletRequest request) throws AvatarException {
		// Gets the header
		String headerinfo = request.getHeader(X_CRAFT_ACTION);
		return headerinfo!=null;
	}
}
